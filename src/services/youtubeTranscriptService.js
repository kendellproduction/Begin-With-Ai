// YouTube Transcript Extraction and Content Generation Service

import logger from '../utils/logger';

/**
 * Extracts video ID from various YouTube URL formats
 */
const extractVideoId = (url) => {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
    /youtube\.com\/v\/([^&\n?#]+)/,
    /youtube\.com\/watch\?.*v=([^&\n?#]+)/
  ];
  
  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match && match[1]) {
      return match[1];
    }
  }
  
  throw new Error('Invalid YouTube URL format');
};

/**
 * Fetches transcript using Firebase Function with proper error handling
 */
const fetchTranscript = async (videoId) => {
  try {
    // Use Firebase Function for transcript extraction
    const response = await fetch(`${process.env.REACT_APP_FIREBASE_FUNCTIONS_URL || 'http://localhost:5001/beginai1/us-central1'}/extractYouTubeTranscript`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ videoId })
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      
      // If no transcript available, try auto-generated captions
      if (errorData.error?.includes('transcript') || errorData.error?.includes('captions')) {
        console.warn('No manual transcript found, attempting to extract auto-generated captions...');
        return await extractAutoGeneratedCaptions(videoId);
      }
      
      throw new Error(errorData.error || 'Failed to fetch transcript');
    }
    
    const data = await response.json();
    
    // Validate transcript quality
    if (data.transcript && data.transcript.length > 100) {
      return data.transcript;
    } else {
      throw new Error('Transcript too short or empty - unable to generate meaningful lesson content');
    }
  } catch (error) {
    logger.error('Error fetching transcript:', error);
    throw new Error(`Unable to extract transcript from video: ${error.message}. Please try a video with available transcripts or captions.`);
  }
};

/**
 * Attempts to extract auto-generated captions when manual transcript unavailable
 */
const extractAutoGeneratedCaptions = async (videoId) => {
  try {
    // This would call YouTube Data API for video metadata and auto-captions
    // For now, we'll check if we have any way to get real content
    const videoMetadata = await getVideoMetadataFromAPI(videoId);
    
    if (videoMetadata && videoMetadata.description && videoMetadata.description.length > 300) {
      // Only use description if it's substantial enough
      const descriptionBasedContent = generateContentFromDescription(videoMetadata);
      
      // Validate that the description actually contains meaningful content
      if (descriptionBasedContent.length > 500) {
        return descriptionBasedContent;
      }
    }
    
    // If we can't get meaningful content, fail gracefully
    throw new Error('No transcript or meaningful captions available for this video');
  } catch (error) {
    logger.error('Error extracting auto-captions:', error);
    throw new Error('Unable to extract any usable content from this video - no transcript or captions available');
  }
};

/**
 * Gets video metadata from YouTube API
 */
const getVideoMetadataFromAPI = async (videoId) => {
  try {
    // This would use YouTube Data API to get real metadata
    // For now, return null to indicate no metadata is available
    // In production, this would make an actual API call
    console.warn('YouTube Data API not configured - unable to fetch video metadata');
    return null;
  } catch (error) {
    logger.error('Error fetching video metadata:', error);
    return null;
  }
};

/**
 * Generates content from video description and metadata (only if substantial)
 */
const generateContentFromDescription = (metadata) => {
  const { title, description, tags, duration } = metadata;
  
  // Only proceed if description is substantial
  if (!description || description.length < 300) {
    throw new Error('Video description too short to generate meaningful lesson content');
  }
  
  return `
    Video Title: ${title}
    
    Description-based Content:
    ${description}
    
    ${tags && tags.length > 0 ? `Topics: ${tags.join(', ')}` : ''}
    
    Duration: ${duration || 'Unknown'}
    
    Note: This content was generated from the video description only, as no transcript was available.
  `;
};

/**
 * Enhanced content analysis that determines lesson vs module structure
 */
const analyzeContentStructure = (transcript) => {
  const analysis = {
    wordCount: 0,
    estimatedReadingTime: 0,
    topicCount: 0,
    technicalDensity: 0,
    shouldBeModule: false,
    suggestedLessonCount: 1,
    contentType: 'lesson',
    complexity: 'intermediate'
  };

  // Basic metrics
  const words = transcript.split(/\s+/).filter(word => word.length > 0);
  analysis.wordCount = words.length;
  analysis.estimatedReadingTime = Math.ceil(words.length / 200); // 200 WPM

  // Identify distinct topics/sections
  const sections = transcript.split(/(?:PART \d+|Chapter \d+|Section \d+|\n\n\n)/i);
  analysis.topicCount = Math.max(1, sections.length - 1);

  // Technical term analysis
  const technicalTerms = [
    'algorithm', 'machine learning', 'neural network', 'artificial intelligence', 'ai',
    'data science', 'api', 'framework', 'library', 'programming', 'coding',
    'development', 'software', 'technology', 'computer', 'digital', 'model',
    'training', 'supervised', 'unsupervised', 'reinforcement', 'python',
    'tensorflow', 'pytorch', 'scikit', 'statistics', 'probability'
  ];

  const technicalTermCount = technicalTerms.reduce((count, term) => {
    const regex = new RegExp(`\\b${term}\\b`, 'gi');
    return count + (transcript.match(regex) || []).length;
  }, 0);

  analysis.technicalDensity = technicalTermCount / words.length * 1000; // per 1000 words

  // Determine structure based on analysis
  if (analysis.wordCount > 3000 || analysis.topicCount > 4 || analysis.technicalDensity > 15) {
    analysis.shouldBeModule = true;
    analysis.contentType = 'module';
    analysis.suggestedLessonCount = Math.min(8, Math.max(2, Math.ceil(analysis.topicCount / 1.5)));
  }

  // Determine complexity
  if (analysis.technicalDensity > 20 || analysis.wordCount > 5000) {
    analysis.complexity = 'advanced';
  } else if (analysis.technicalDensity < 8 && analysis.wordCount < 1500) {
    analysis.complexity = 'beginner';
  }

  return analysis;
};

/**
 * Uses AI to generate structured learning content from transcript
 */
const generateContentFromTranscript = async (transcript, options = {}) => {
  const {
    targetAudience = 'intermediate',
    contentType = 'technical',
    modulesCount = 'auto',
    includeQuizzes = true,
    includePractical = true
  } = options;
  
  // This would typically call an AI service like OpenAI GPT-4 or Anthropic Claude
  // For demo purposes, we'll simulate the AI response
  
  const prompt = `
    Convert the following video transcript into a structured learning path with modules and lessons.
    
    Transcript: ${transcript}
    
    Target Audience: ${targetAudience}
    Content Type: ${contentType}
    
    Create a JSON structure with:
    1. Learning path title and description
    2. Multiple modules (chapters)
    3. Multiple lessons per module
    4. Content pages for each lesson
    5. Interactive elements where appropriate
    
    Format each lesson with:
    - Title
    - Learning objectives
    - Content broken into digestible pages
    - Interactive elements (quizzes, coding exercises, etc.)
    - Estimated time to complete
    
    Make it engaging and educational.
  `;
  
  try {
    // Simulate AI processing with structured content generation
    return await simulateAIContentGeneration(transcript, options);
  } catch (error) {
    logger.error('Error generating content from transcript:', error);
    throw error;
  }
};

/**
 * Simulates AI content generation (replace with actual AI service in production)
 */
const simulateAIContentGeneration = async (transcript, options) => {
  // Simulate API delay
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  // Extract key topics from transcript (simplified)
  const topics = extractKeyTopics(transcript);
  
  // Generate structured content
  const learningPath = {
    title: generatePathTitle(topics),
    description: generatePathDescription(topics),
    estimatedDuration: '3-4 hours',
    targetAudience: [options.targetAudience || 'intermediate'],
    isPremium: false,
    published: false,
    modules: generateModules(topics, options)
  };
  
  return learningPath;
};

/**
 * Extracts key topics from transcript using simple NLP
 */
const extractKeyTopics = (transcript) => {
  const sentences = transcript.split(/[.!?]+/).filter(s => s.trim().length > 10);
  const commonWords = new Set(['the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'this', 'that', 'these', 'those', 'a', 'an']);
  
  // Simple keyword extraction
  const wordFreq = {};
  const words = transcript.toLowerCase()
    .replace(/[^\w\s]/g, ' ')
    .split(/\s+/)
    .filter(word => word.length > 3 && !commonWords.has(word));
  
  words.forEach(word => {
    wordFreq[word] = (wordFreq[word] || 0) + 1;
  });
  
  // Get top keywords
  const topKeywords = Object.entries(wordFreq)
    .sort(([,a], [,b]) => b - a)
    .slice(0, 10)
    .map(([word]) => word);
  
  return topKeywords;
};

/**
 * Generates a learning path title based on extracted topics
 */
const generatePathTitle = (topics) => {
  const mainTopic = topics[0] || 'technology';
  const titleTemplates = [
    `Complete Guide to ${mainTopic.charAt(0).toUpperCase() + mainTopic.slice(1)}`,
    `Mastering ${mainTopic.charAt(0).toUpperCase() + mainTopic.slice(1)}`,
    `${mainTopic.charAt(0).toUpperCase() + mainTopic.slice(1)} Fundamentals`,
    `Introduction to ${mainTopic.charAt(0).toUpperCase() + mainTopic.slice(1)}`
  ];
  
  return titleTemplates[Math.floor(Math.random() * titleTemplates.length)];
};

/**
 * Generates a learning path description
 */
const generatePathDescription = (topics) => {
  return `A comprehensive learning path covering ${topics.slice(0, 3).join(', ')} and related concepts. This course will take you from basics to practical implementation with hands-on exercises and real-world examples.`;
};

/**
 * Generates modules and lessons based on topics
 */
const generateModules = (topics, options) => {
  const modules = [];
  const modulesPerTopic = Math.ceil(topics.length / 3);
  
  for (let i = 0; i < Math.min(4, topics.length); i += modulesPerTopic) {
    const moduleTopics = topics.slice(i, i + modulesPerTopic);
    const module = {
      title: `Module ${Math.floor(i / modulesPerTopic) + 1}: ${moduleTopics[0].charAt(0).toUpperCase() + moduleTopics[0].slice(1)}`,
      description: `Learn about ${moduleTopics.join(', ')} and their practical applications.`,
      lessons: generateLessons(moduleTopics, options)
    };
    
    modules.push(module);
  }
  
  return modules;
};

/**
 * Generates lessons for a module
 */
const generateLessons = (topics, options) => {
  const lessons = [];
  
  topics.forEach((topic, index) => {
    const lesson = {
      title: `Understanding ${topic.charAt(0).toUpperCase() + topic.slice(1)}`,
      lessonType: index === 0 ? 'concept_explanation' : 'interactive_practice',
      estimatedTimeMinutes: 15 + (index * 5),
      xpAward: 25,
      learningObjectives: [
        `Understand the basics of ${topic}`,
        `Learn practical applications of ${topic}`,
        `Apply ${topic} concepts in real scenarios`
      ],
      content: generateLessonContent(topic, options)
    };
    
    lessons.push(lesson);
  });
  
  // Add a practical lesson at the end
  if (options.includePractical) {
    lessons.push({
      title: 'Hands-on Practice',
      lessonType: 'code_generation_interaction',
      estimatedTimeMinutes: 30,
      xpAward: 50,
      learningObjectives: [
        'Apply learned concepts in practice',
        'Build a working example',
        'Gain confidence through hands-on experience'
      ],
      content: generatePracticalContent(topics)
    });
  }
  
  return lessons;
};

/**
 * Generates content pages for a lesson
 */
const generateLessonContent = (topic, options) => {
  const content = [
    {
      type: 'text',
      value: `Welcome to this lesson on ${topic}. In this session, we'll explore the fundamentals and practical applications.`
    },
    {
      type: 'text',
      value: `${topic.charAt(0).toUpperCase() + topic.slice(1)} is an important concept that forms the foundation of many modern applications. Let's break it down step by step.`
    },
    {
      type: 'ai_professor_tip',
      value: `Pro tip: The best way to understand ${topic} is through practice and real-world examples. Don't just read - try it out!`
    }
  ];
  
  // Add interactive elements based on content type
  if (options.includeQuizzes && Math.random() > 0.5) {
    content.push({
      type: 'quiz',
      question: `What is the main benefit of understanding ${topic}?`,
      options: [
        { text: 'It sounds impressive', correct: false },
        { text: 'It enables practical applications', correct: true },
        { text: 'It\'s required for certification', correct: false },
        { text: 'It\'s trending on social media', correct: false }
      ],
      feedback: `Correct! Understanding ${topic} enables you to build practical applications and solve real-world problems.`
    });
  }
  
  content.push({
    type: 'text',
    value: `Now that you understand the basics of ${topic}, let's look at some practical examples and how you can apply this knowledge in your own projects.`
  });
  
  return content;
};

/**
 * Generates practical/hands-on content
 */
const generatePracticalContent = (topics) => {
  return [
    {
      type: 'text',
      value: `Time to put your knowledge into practice! In this hands-on exercise, you'll work with ${topics.join(', ')} to build something real.`
    },
    {
      type: 'code_challenge',
      value: `Create a simple project that demonstrates the concepts we've learned. Use the sandbox below to experiment and build.`
    },
    {
      type: 'ai_professor_tip',
      value: 'Remember, the goal is to learn by doing. Don\'t worry about perfection - focus on understanding the concepts!'
    }
  ];
};

/**
 * Main function to generate lessons from YouTube URL with enhanced analysis
 */
export const generateLessonsFromYouTube = async (youtubeUrl, options = {}) => {
  try {
    // Step 1: Extract video ID
    const videoId = extractVideoId(youtubeUrl);
    
    // Step 2: Fetch transcript with enhanced fallback handling
    const transcript = await fetchTranscript(videoId);
    
    // Step 3: Analyze content structure to determine if it should be lesson or module
    const contentAnalysis = analyzeContentStructure(transcript);
    
    // Step 4: Merge analysis with user options
    const enhancedOptions = {
      ...options,
      contentAnalysis,
      suggestedStructure: contentAnalysis.contentType,
      complexity: contentAnalysis.complexity,
      estimatedLessons: contentAnalysis.suggestedLessonCount
    };
    
    // Step 5: Generate structured content based on analysis
    const learningPath = await generateContentFromTranscript(transcript, enhancedOptions);
    
    // Step 6: Add comprehensive metadata
    learningPath.contentAnalysis = contentAnalysis;
    learningPath.sourceUrl = youtubeUrl;
    learningPath.sourceType = 'youtube_video';
    learningPath.createdAt = new Date();
    learningPath.generatedBy = 'ai_transcript_processor';
    learningPath.processingOptions = enhancedOptions;
    
    // Add difficulty and structure recommendations
    learningPath.recommendedDifficulty = contentAnalysis.complexity;
    learningPath.recommendedStructure = contentAnalysis.contentType;
    
    return learningPath;
  } catch (error) {
    logger.error('Error generating lessons from YouTube:', error);
    throw error;
  }
};

/**
 * Validates YouTube URL format
 */
export const validateYouTubeUrl = (url) => {
  try {
    extractVideoId(url);
    return { isValid: true };
  } catch (error) {
    return { 
      isValid: false, 
      error: 'Please enter a valid YouTube URL (e.g., https://www.youtube.com/watch?v=VIDEO_ID)' 
    };
  }
};

/**
 * Gets video metadata (title, duration, etc.)
 */
export const getVideoMetadata = async (youtubeUrl) => {
  try {
    const videoId = extractVideoId(youtubeUrl);
    
    // Use Firebase Function for metadata extraction
    const response = await fetch(`${process.env.REACT_APP_FIREBASE_FUNCTIONS_URL || 'http://localhost:5001/beginai1/us-central1'}/getYouTubeMetadata`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ videoId })
    });
    
    if (!response.ok) {
      // Fallback to basic metadata
      return {
        title: 'Video Title (API Key Required)',
        duration: 'Duration not available',
        description: 'Description not available',
        thumbnailUrl: `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`,
        channelName: 'Channel not available'
      };
    }
    
    const data = await response.json();
    return data.metadata;
  } catch (error) {
    logger.error('Error getting video metadata:', error);
    throw error;
  }
};

/**
 * Preview content before creation
 */
export const previewGeneratedContent = async (youtubeUrl, options = {}) => {
  const learningPath = await generateLessonsFromYouTube(youtubeUrl, options);
  
  return {
    title: learningPath.title,
    description: learningPath.description,
    moduleCount: learningPath.modules.length,
    lessonCount: learningPath.modules.reduce((total, module) => total + module.lessons.length, 0),
    estimatedDuration: learningPath.estimatedDuration,
    topics: learningPath.modules.map(module => module.title)
  };
}; 